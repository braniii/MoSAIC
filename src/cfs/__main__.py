"""CLI of MoSAIC motion.

MIT License
Copyright (c) 2021, Daniel Nagel
All rights reserved.

"""
import datetime
import getpass
import platform
import sys

import click
import numpy as np
import pandas as pd

import cfs

NORMALIZES = ['joint', 'geometric', 'arithmetic', 'min', 'max']
METRICS = ['correlation', 'NMI', 'JSD', 'GY']
MODES = ['CPM', 'modularity']


def get_rui(submod):
    """Get the runetime user information, to store as comment."""
    # get time without microseconds
    date = datetime.datetime.now()
    date = date.isoformat(sep=' ', timespec='seconds')

    rui = {
        'user': getpass.getuser(),
        'pc': platform.node(),
        'date': date,
        'args': ' '.join(sys.argv),
        'submod': submod,
    }

    return (
        'This file was generated by cfs {submod}:\n{args}' +
        '\n\n{date}, {user}@{pc}'
    ).format(**rui)


@click.group(help=f"""MoSAIC motion v{cfs.__version__}

\b
Molecular systems automated identification of collective motion, is
a correlation based feature selection framework for MD data.
Copyright (c) 2021, Georg Diez and Daniel Nagel
""",
)
def main():
    """Empty group to show on help available submodules."""
    pass


@main.command(
    help='Creating similarity matrix of coordinates.',
    no_args_is_help=True,
)
@click.option(
    '--metric',
    default='correlation',
    show_default=True,
    type=click.Choice(METRICS, case_sensitive=True),
    help='Metric used to estimate similarity measure matrix.',
)
@click.option(
    '--normalize-method',
    type=click.Choice(NORMALIZES, case_sensitive=True),
    help=(
        'Only required for metric="NMI". Determines the normalization factor '
        'for the mutual information. See docs for help.'
    ),
)
@click.option(
    '--online',
    is_flag=True,
    help=(
        'Is set the correlation is calculated using the Welford online '
        'algorithm. This is much slower but needs less RAM and is sutable '
        'for larger files. Online metric=correlation is supported.'
    ),
)
@click.option(
    '-i',
    '--input',
    'input_file',
    required=True,
    type=click.Path(exists=True),
    help=(
        'Path to input file. Needs to be of shape (n_samples, n_features).'
        ' All command lines need to start with "#". By default np.float16'
        ' is used for the datatype.'
    ),
)
@click.option(
    '-o',
    '--output',
    'output_file',
    required=True,
    type=click.Path(),
    help=(
        'Path to output file. Will be a matrix of shape (n_features, '
        'n_features).'
    ),
)
@click.option(
    '-v',
    '--verbose',
    is_flag=True,
    help='Activate verbose mode.',
)
def similarity(
    metric, online, normalize_method, input_file, output_file, verbose,
):
    if verbose:
        click.echo('\nCFS SIMILARITY\n~~~ Initialize similarity class')
    sim = cfs.Similarity(
        metric=metric,
        online=online,
        normalize_method=normalize_method,
    )
    if online:
        if verbose:
            click.echo(f'~~~ Fit online {input_file}')
        sim.fit(input_file)
    else:
        if verbose:
            click.echo(f'~~~ Load file {input_file}')
        X = pd.read_csv(
            input_file,
            sep=r'\s+',
            header=None,
            comment='#',
            dtype=np.float16,
        ).values
        if verbose:
            click.echo('~~~ Fit input.')
        sim.fit(X)

    if verbose:
        click.echo(f'~~~ Store similarity matrix in {output_file}')
    np.savetxt(
        output_file,
        sim.matrix_,
        fmt='%.5f',
        header=get_rui('similarity'),
    )


@main.command(
    help='Clustering similarity matrix of coordinates.',
    no_args_is_help=True,
)
@click.option(
    '--mode',
    default='CPM',
    show_default=True,
    type=click.Choice(MODES, case_sensitive=True),
    help='Mode used for Leiden clustering.',
)
@click.option(
    '-i',
    '--input',
    'input_file',
    required=True,
    type=click.Path(exists=True),
    help='Path to input file. Needs to be of shape (n_features, n_features).',
)
@click.option(
    '-v',
    '--verbose',
    is_flag=True,
    help='Activate verbose mode.',
)
def clustering(mode, input_file, verbose):
    if verbose:
        click.echo('\nCFS CLUSTERING\n~~~ Initialize clustering class')

    # move to option
    weighted = True
    n_neighbors = None,
    resolution_parameter = None,

    clust = cfs.Clustering(
        mode=mode,
        weighted=weighted,
        n_neighbors=n_neighbors,
        resolution_parameter=resolution_parameter,
    )

    if verbose:
        click.echo(f'~~~ Load file {input_file}')
    X = pd.read_csv(
        input_file,
        sep=r'\s+',
        header=None,
        comment='#',
        dtype=np.float16,
    ).values
    if verbose:
        click.echo('~~~ Fit input.')
    clust.fit(X)


@main.command(
    help='Embedd similarity matrix with UMAP.',
    no_args_is_help=True,
)
@click.option(
    '--n-components',
    default=cfs.UMAPSimilarity._default_n_components,  # noqa: WPS437
    show_default=True,
    type=click.IntRange(min=2),
    help='Dimensionality of UMAP embedding.',
)
@click.option(
    '--n-neighbors',
    default=cfs.UMAPSimilarity._default_n_neighbors,  # noqa: WPS437
    show_default=True,
    type=click.IntRange(min=2),
    help='Number of nearest neighbors used for estimating manifold.',
)
@click.option(
    '--densmap/--umap',
    default=True,
    is_flag=True,
    show_default=True,
)
@click.option(
    '-i',
    '--input',
    'input_file',
    required=True,
    type=click.Path(exists=True),
    help=(
        'Path to input file. Needs to be of shape (n_features, n_features).'
        ' All command lines need to start with "#".'
    ),
)
@click.option(
    '-o',
    '--output',
    'output_file',
    required=True,
    type=click.Path(),
    help=(
        'Path to output file. Will be a matrix of shape (n_features, '
        'n_features).'
    ),
)
@click.option(
    '-v',
    '--verbose',
    is_flag=True,
    help='Activate verbose mode.',
)
def umap(
    n_components, n_neighbors, densmap, input_file, output_file, verbose,
):
    if verbose:
        click.echo('\nCFS UMAP\n~~~ Initialize umap similarity class')
    umap = cfs.UMAPSimilarity(
        densmap=densmap,
        n_neighbors=n_neighbors,
        n_components=n_components,
    )
    if verbose:
        click.echo(f'~~~ Load file {input_file}')
    X = pd.read_csv(
        input_file,
        sep=r'\s+',
        header=None,
        comment='#',
        dtype=np.float16,
    ).values
    if verbose:
        click.echo('~~~ Fit input.')
    umap.fit(X)
    if verbose:
        click.echo(f'~~~ Store similarity matrix in {output_file}')
    np.savetxt(
        output_file,
        umap.matrix_,
        fmt='%.5f',
        header=get_rui('similarity'),
    )


if __name__ == '__main__':
    main()
